<!DOCTYPE html>
<html>
  <meta charset="utf-8">
  <!-- <meta name="apple-mobile-web-app-capable" content="yes"> -->
  <!-- http://curran.github.io/screencasts/splittingCharts/examples/viewer/#/17 -->
  <!-- http://bl.ocks.org/mbostock/3885705 transitions-->
  <meta name="viewport" content="minimal-ui">
  <style>
    body {
      background-color: #0C0C1A;
      margin:           0px;
      padding:          0px;
      overflow:         hidden;
    }

    .axis line {
      fill:         none;
      stroke:       #ffffff;
      stroke-width: 1.6px;
    }
    .axis path {
      fill:            none;
      stroke:          #ffffff;
      stroke-width:    2.5px;
      shape-rendering: crispEdges;
    }
    .axis text {
      font: 12px sans-serif;
      shape-rendering: crispEdges;
      stroke-width:    1px;
      stroke: white;
      font-color: #fff;
    }
    .stations {
    }
    .station{
      fill:#0C0C1A;
    }
    .station:nth-child(even) {
      fill:#1A3047;
    }
    .station .name{
      fill: white;
    }

    .workflow {
      stroke:          steelblue;
      stroke-width:    1px;
    }

    svg {
      background-color: #0C0C1A
    }
  </style>
  
  <body>
  </body>


  <script src="http://d3js.org/d3.v3.js"></script>
  <script>
    "use strict";
    
    //User Defined Variables
    var rowHeight   = 45;
    var xAxisHeight = 30;
    var xAxisWidth  = 3000;
    var stationTextHeight = 20;
    var stationTextPadding = {top: 10, right: 0, bottom: 0, left: 10};

    var margin      = {top: 0, right: 0, bottom: 30, left: 0};
    var outerWidth  = document.documentElement.clientWidth;
    var outerHeight = document.documentElement.clientHeight;
    var startOfDayHour = 8; //used for fake data
    var stations =   {
                      0:"En Route",
                      1:"Sierra One",
                      2:"Shed",
                      3:"Transit",
                      4:"Stinger Gate",
                      5:"Sally Port",
                      6:"Warehouse",
                      7:"PA"
                    }

    //Calculated Variables
    var innerWidth     = outerWidth   - margin.left - margin.right;
    var innerHeight    = outerHeight  - margin.top  - margin.bottom;
    var unixHour       = 1000*60*60;
    var unixMinute     = 1000*60;
    var vpStartHours   = (outerWidth/2)/(xAxisWidth/24);  //startHours is the time where the Viewport's (middle of screen) y axis naturally rests.  Its time in hours.
    var unixStartHours = unixHour * vpStartHours; 
    var now            = new Date(Date.now());
    var nowYear        = now.getFullYear();
    var nowMonth       = now.getMonth();
    var nowDay         = now.getDay()-1;
    var nowHours       = now.getHours();
    var nowMinutes     = now.getMinutes();
    //Variables (to be used)
    var stationHeight;
    var deliveries=[];
    var workflowsFakeData=[];
    var startingX;
    var duration, variation, variationMinutes;
    var yDeliveryScale;
    var stationCounts =[];
    var stationStackedCount=[];
    var stationStacked=[];
    var panBounds;

    //scales
    var xScale = d3.time.scale.utc()
          .domain([+new Date(nowYear, nowMonth, nowDay),                 +new Date(nowYear, nowMonth, nowDay,24)])
          .range( [0,                                     xAxisWidth]);

    var yDeliveryScale = d3.scale.linear()
          .domain([1,7])
          .range([1+rowHeight,7*rowHeight]);

    var viewportScale = d3.time.scale.utc()
          .domain([+new Date(nowYear, nowMonth, nowDay)+unixStartHours,  +new Date(nowYear, nowMonth, nowDay,24)-unixStartHours])
          .range( [0,                                     -1*xAxisWidth+outerWidth]);
          
    startingX = viewportScale(new Date(nowYear,nowMonth,nowDay,nowHours,nowMinutes));

    var xAxis = d3.svg.axis()
          .ticks(d3.time.hours, 1)
          .tickFormat(d3.time.format('%H'))
          .scale(xScale);


    //Create Data
    var workflowsFakeData = generateWorkflows(startOfDayHour);
    
    var deliveries = d3.nest()  //group by delivery
          .key(function(d) { return d.delivery; })
          .entries(workflowsFakeData);


    //interactivity
    var xAxisTranslation = d3.behavior.zoom()
        .scaleExtent([1, 6])
        .translate([startingX,0])
        .on("zoom", moveXAxis);

    function moveXAxis(a,b) {
      var eventxTranslation = d3.event.translate[0];
      var eventyTranslation = d3.event.translate[1];

      deliveriesGroup.attr("transform", "translate(" + [eventxTranslation,eventyTranslation] + ")scale(1)");
      stationsGroup.attr("transform", "translate(" + [0,eventyTranslation] + ")scale(1)");
      xAxisGroup.attr("transform", "translate(" + [eventxTranslation,innerHeight] + ")scale(1)");
      
      if (panBounds.left > eventxTranslation || eventxTranslation > panBounds.right || eventyTranslation > panBounds.top || eventyTranslation < panBounds.bottom ) {
        var translation = [
                            Math.max(Math.min(eventxTranslation, panBounds.right), panBounds.left),
                            Math.max(Math.min(eventyTranslation, panBounds.top)  , panBounds.bottom),
                          ];
        deliveriesGroup.attr("transform", "translate(" + [translation[0],translation[1]] + ")scale(1)");
        stationsGroup.attr("transform", "translate(" + [0,translation[1]] + ")scale(1)");
        xAxisGroup.attr("transform", "translate(" + [translation[0],innerHeight] + ")scale(1)");
        xAxisTranslation.translate(translation);
      }
    }

    //Structure
    var svg = d3.select("body").append("svg")
          .attr("width",  outerWidth)
          .attr("height", outerHeight)
          .call(xAxisTranslation);;

        var stationsGroup = svg.append("g")
              .attr("class", "stations")
              .attr('transform', 'translate(' + 0 + "," + 0 + ')')

        var g = svg.append("g")
              .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

            var deliveriesGroup = g.append("g")
                  .attr("class", "deliveries")
                  .attr('transform', 'translate(' + startingX + "," + 0 + ')');

                var yAxisGroup = deliveriesGroup.append("g")
                    .attr("class", "y axis");

            var xAxisGroup = g.append("g")
                  .attr("class", "x axis")
                  .attr('transform', 'translate(' + startingX + "," +  innerHeight + ')');

     
    function render(data){
      //data manipulation
      data = updateCurrentStationCalc(data);
      var stationCounts       = stationCountCalc(data);                                         // Gets the number of deliveries for every station
      var stationStackedCount = stationStackedCountCalc(stationCounts);
      var stationStacked      = stationStackedCalc(stationCounts,stationStackedCount,stations);

      stationHeight = (stationStacked[stationStackedCount.length-1].y0*rowHeight) + 
                      (stationStacked[stationStackedCount.length-1].y * rowHeight);
      panBounds = { top:    0,
                    right:  0,
                    bottom: (-1*stationHeight) + innerHeight - xAxisHeight,
                    left:   (-1*xAxisWidth) + outerWidth};

      data = data.sort(compare);
      
      var data = d3.nest() // groupByStation
          .key(function(d) { return d.currentStation; })
          .entries(data);

      data = stackDeliveriesCalc(stationStackedCount,data); // set the yIndex for every delivery (make sure )


      // Setup stations overlay and text
      var stationsSelectAll = stationsGroup.selectAll(".station").data(stationStacked);
      stationsSelectAll.enter().append("g").attr("class", "station"); // stations should never exit

      stationsSelectAll.append("rect")
          .attr("x", function(d,i) { return 0;})
          .attr("y", function(d,i) { return d.y0*rowHeight + (rowHeight/2);})
          .attr("width",innerWidth)
          .attr("height", function(d,i) { return d.y*rowHeight;})

      stationsSelectAll.append("text")
          .attr("x", function(d,i) { return stationTextPadding.left;})
          .attr("y", function(d,i) { return d.y0*rowHeight + (rowHeight/2) + stationTextHeight + stationTextPadding.top;})
          .text(function(d,i){return d.name})
          .attr("class","name")
          .attr("font-size", stationTextHeight + "px");


      // Setup axii
      xAxisGroup.call(xAxis);
      yAxisGroup.append("line")
          .style("stroke-dasharray", ("2, 2"))
          .attr("x1", xScale(now))
          .attr("y1", margin.top)
          .attr("x2", xScale(now))
          .attr("y2", stationHeight+ xAxisHeight);


      // Setup Stations
      var stationsSelectAll2 = deliveriesGroup.selectAll(".station").data(data);
      stationsSelectAll2.enter().append("g").attr("class", "station");
      stationsSelectAll2.exit().remove();

      // Setup Deliveries
      var deliveriesSelectAll = stationsSelectAll2.selectAll(".delivery").data(function(d){
        return d.values;
      });
      deliveriesSelectAll.enter().append("g").attr("class", "delivery");
      deliveriesSelectAll
          .attr('transform', function(d){
            return 'translate(' + 0 + "," + yDeliveryScale(d.yIndex+1)+ ')';
          })

      // Setup Workflows
      var workflowsSelectAll = deliveriesSelectAll.selectAll(".workflow").data(function(d){
        return d.values;
      });
      workflowsSelectAll.enter().append("line");
      workflowsSelectAll.exit().remove();
      workflowsSelectAll
          .attr("x1", function(d,i) { return xScale(d.startTime); })
          .attr("y1", function(d,i) { 
              return 0;
              // return yDeliveryScale(d.yIndex); 
            })
          .attr("x2", function(d,i) { return xScale(d.endTime); })
          .attr("y2", function(d,i) { 
            return 0;
            // return yDeliveryScale(d.yIndex); 
          })
          .attr("class", "workflow");
    }

    render(deliveries);

    window.onresize = resize;



    //utility
    function resize() { 
       outerWidth  = document.documentElement.clientWidth;
       outerHeight = document.documentElement.clientHeight;
      innerWidth     = outerWidth   - margin.left - margin.right;
      innerHeight    = outerHeight  - margin.top  - margin.bottom;
      svg.remove();
       svg = d3.select("body").append("svg")
          .attr("width",  outerWidth)
          .attr("height", outerHeight)
          .call(xAxisTranslation);;

         stationsGroup = svg.append("g")
              .attr("class", "stations")
              .attr('transform', 'translate(' + 0 + "," + 0 + ')')
              

         g = svg.append("g")
              .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

             deliveriesGroup = g.append("g")
                  .attr("class", "deliveries")
                  .attr('transform', 'translate(' + startingX + "," + 0 + ')');

                yAxisGroup = deliveriesGroup.append("g")
                  .attr("class", "y axis");

             xAxisGroup = g.append("g")
                  .attr("class", "x axis")
                  .attr('transform', 'translate(' + startingX + "," +  innerHeight + ')');

      svg.attr("width", outerWidth).attr("height", outerHeight);
      render(deliveries);

      deliveriesGroup.attr("transform", "translate(" + [startingX,0] + ")scale(1)");
      stationsGroup.attr("transform", "translate(" + [0,0] + ")scale(1)");
      xAxisGroup.attr("transform", "translate(" + [startingX,innerHeight] + ")scale(1)");
    }

    function updateCurrentStationCalc(data){//update every delivery w/ its current station
      var workflow;
      var currentStation = 0;

      var now = new Date(Date.now());


      for (var i = 0; i < data.length; i++) {
        currentStation = 0;

        for (var j = 0; j < data[i].values.length; j++) {
           workflow = data[i].values[j];
          // debugger;
          if(isTimeBetweenTime(now,workflow.startTime,workflow.endTime)){
            currentStation = j;
          }
        }
      
        data[i].currentStation = currentStation;
      };
      return data;
    }

    function stationCountCalc(data){ // [7, 5, 5, 1, 4, 1, 1, 1] Gets the number of deliveries for every station
      var stationCounts =[0,0,0,0,0,0,0,0];      //[7, 5, 5, 1, 4, 1, 1, 1]

      for(var i = 0;i<data.length;i++){
        stationCounts[data[i].currentStation]++;
      }
      for (var i = 0; i < stationCounts.length; i++) { //make sure they have at least 1
        stationCounts[i] = stationCounts[i] || 1;
      };

      return stationCounts;
    }

    function stationStackedCountCalc(stationCounts){ //[7, 12, 17, 18, 22, 23, 24, 25]
      var stationStackedCount=[0,0,0,0,0,0,0,0]; 
      
      stationStackedCount[0] = stationCounts[0];
      for (var i = 1; i < stationCounts.length; i++) {
        stationStackedCount[i] = stationStackedCount[i-1]+ stationCounts[i];
      };

      return stationStackedCount;
    }

    function stationStackedCalc(stationCounts,stationStackedCount,stations){//stacks each station with its y0 index and height
      var stationStacked=[];                     //[Object(name:EnRoute, y:7,y0:0),Object...]

      stationStacked[0]={
                          "y0":0,
                          "y":stationCounts[0],
                          "name": stations[0]}

      //this needs to factor in zooming, or add it to zoom section
      for (var i = 1; i < stationStackedCount.length; i++) {
        stationStacked[i] = {
                              "y0":stationStackedCount[i-1],
                              "y":stationCounts[i],
                              "name":stations[i]
                            };
      };
      return stationStacked
    }

    function stackDeliveriesCalc(stationStackedCount,stationData) { //we set the starting yIndex. of each Delivery.  We have to account for stations w/o a delivery

      for (var i = 0; i < stationData.length; i++) {
        for (var j = 0; j < stationData[i].values.length; j++) {
          if(i==0){
            stationData[i].values[j].yIndex = j;
          } else {
            stationData[i].values[j].yIndex = stationStackedCount[stationData[i].key-1] + j;
          }
        }
      }

      return stationData;
    }

    function compare(a,b) {
      if (a.currentStation < b.currentStation)
        return -1;
      else if (a.currentStation > b.currentStation)
        return 1;
      else 
        return 0;
    }
    function isTimeBetweenTime(time, start,end){
      return start <= time && time <= end;
    }

    function generateWorkflows(startOfDayHour){
      var workflows=[];
      for(var i = 21; i > 0; i--){
        variation =        Math.random() * 1;
        variationMinutes = Math.random() * 60;
        workflows.push({  startTime: new Date(nowYear, nowMonth, nowDay,startOfDayHour+(i*.2), 5), 
                          endTime:   new Date(nowYear, nowMonth, nowDay,startOfDayHour+(i*.2),25),
                          delivery: i,
                          station:Math.round(0),
                        });

        workflows.push({  startTime: new Date(nowYear, nowMonth, nowDay,startOfDayHour+(i*.2),28), 
                          endTime:   new Date(nowYear, nowMonth, nowDay,startOfDayHour+(i*.2),48),
                          delivery: i,
                          station:Math.round(1),
                        });

        workflows.push({  startTime: new Date(nowYear, nowMonth, nowDay,startOfDayHour+(i*.2),56), 
                          endTime:   new Date(nowYear, nowMonth, nowDay,startOfDayHour+(i*.2)+1,40),
                          delivery: i,
                          station:Math.round(2),
                        });

        workflows.push({  startTime: new Date(nowYear, nowMonth, nowDay,startOfDayHour+(i*.2)+1, 44), 
                          endTime:   new Date(nowYear, nowMonth, nowDay,startOfDayHour+(i*.2)+2, 20),
                          delivery: i,
                          station:Math.round(3),
                        });

        workflows.push({  startTime: new Date(nowYear, nowMonth, nowDay,startOfDayHour+(i*.2)+2,22), 
                          endTime:   new Date(nowYear, nowMonth, nowDay,startOfDayHour+(i*.2)+4,12),
                          delivery: i,
                          station:Math.round(4),
                        });

        workflows.push({  startTime: new Date(nowYear, nowMonth, nowDay,startOfDayHour+(i*.2)+4,15), 
                          endTime:   new Date(nowYear, nowMonth, nowDay,startOfDayHour+(i*.2)+4,40),
                          delivery: i,
                          station:Math.round(5),
                        });
        workflows.push({  startTime: new Date(nowYear, nowMonth, nowDay,startOfDayHour+(i*.2)+4,42), 
                          endTime:   new Date(nowYear, nowMonth, nowDay,startOfDayHour+(i*.2)+5,10),
                          delivery: i,
                          station:Math.round(6),
                        });
        workflows.push({  startTime: new Date(nowYear, nowMonth, nowDay,startOfDayHour+(i*.2)+5,14), 
                          endTime:   new Date(nowYear, nowMonth, nowDay,startOfDayHour+(i*.2)+5,36),
                          delivery: i,
                          station:Math.round(7),
                        });
      }
      return workflows;
    }
  </script>
</html>

