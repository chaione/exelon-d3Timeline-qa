<!DOCTYPE html>
<html>
  <meta charset="utf-8">
  <meta name="apple-mobile-web-app-capable" content="yes">

  <!-- http://curran.github.io/screencasts/splittingCharts/examples/viewer/#/17 -->
  <!-- http://bl.ocks.org/mbostock/3885705 transitions-->
  <meta name="viewport" content="minimal-ui">
  <style>
    body {
      background-color: #0C0C1A;
      margin:           0px;
      padding:          0px;
      overflow:         hidden;
    }

    .axis line {
      fill:         none;
      stroke:       #CEE5ED;
      stroke-width: 1px;
    }
    .axis path {
      fill:            none;
      stroke:          #CEE5ED;
      stroke-width:    2.5px;
      shape-rendering: crispEdges;
    }
    .axis text {
      font: 12px sans-serif;
      shape-rendering: crispEdges;
      stroke-width:    1px;
      stroke: white;
      font-color: #CEE5ED;
    }

    .bookEnd {
      fill:#BFFFEA;
    }
    .bookend.notReached {
      opacity:0;
    }

    .color-ahead-left {
      stop-color:#0581A6;
    }
    .color-ahead-right {
      stop-color:#05A9B8;
    }

    .color-late-left {
      stop-color:#C90C14;
    }
    .color-late-right {
      stop-color:#C90C14;
    }

    .color-onTime-left {
      stop-color:#0581A6;
    }
    .color-onTime-right {
      stop-color:#C90C14;
    }

    .stations {
    }
    .station{
      fill:#181F2B;
    }
    .station:nth-child(even) {
      fill:#1B1E23;
    }
    .station .name{
      fill: #BFFFEA;
    }

    .workflow {
      stroke: #017AAA;
      stroke-width:    1px;
    }
    .workflow.ahead {
      stroke:#00B4C2;
    }
    .workflow.late {
      stroke:#CF0C13;
    }
    .workflow.notReached {
      stroke:#363667;
      stroke-width:    2px;
    }

    .workflow.aheadGradient {
      stroke: url(#aheadGradient);
      /*stroke-widtstroke-width: 4;h:1px;*/
      fill:none;
      stroke-width: 4;
    }
    .workflow.lateGradient {
      stroke: url(#lateGradient);
      
    }
    .workflow.onTimeGradient {
      stroke: url(#onTimeGradient);
      
    }

    .yAxis {
      stroke:#D0D1D1;
    }

    svg {
      background-color: #0C0C1A
    }
  </style>
  
  <body>
  </body>


  <script src="http://d3js.org/d3.v3.js"></script>
  <script>
    "use strict";
    console.log('Version 03 15 2016');

    //safari rotate bug fix
    (function(doc) {

      var addEvent = 'addEventListener',
          type = 'gesturestart',
          qsa = 'querySelectorAll',
          scales = [1, 1],
          meta = qsa in doc ? doc[qsa]('meta[name=viewport]') : [];

      function fix() {
        meta.content = 'width=device-width,minimum-scale=' + scales[0] + ',maximum-scale=' + scales[1];
        doc.removeEventListener(type, fix, true);
      }

      if ((meta = meta[meta.length - 1]) && addEvent in doc) {
        fix();
        scales = [.25, 1.6];
        doc[addEvent](type, fix, true);
      }

    }(document));
    
    //User Defined Variables
    var rowHeight   = 45;
    var xAxisHeight = 30;
    var xAxisWidth  = 4500;
    var stationTextHeight = 20;
    var stationTextPadding = {top: 10, right: 0, bottom: 0, left: 10};

    var margin      = {top: 0, right: 0, bottom: 30, left: 0};
    var outerWidth  = document.documentElement.clientWidth;
    var outerHeight = document.documentElement.clientHeight;
    console.log(outerWidth);
    console.log(outerHeight);
    var startOfDayHour = 7; //used for fake data
    var stations =   {
                      0:"En Route",
                      1:"Sierra One",
                      2:"Stinger Gate",
                      3:"Sally Port",
                      4:"Warehouse",
                      5:"PA",
                      6:"Exit"
                    }

    //Calculated Variables
    var innerWidth     = outerWidth   - margin.left - margin.right;
    var innerHeight    = outerHeight  - margin.top  - margin.bottom;
    var unixHour       = 1000*60*60;
    var unixMinute     = 1000*60;
    var vpStartHours   = (outerWidth/2)/(xAxisWidth/24);  //startHours is the time where the Viewport's (middle of screen) y axis naturally rests.  Its time in hours.
    var unixStartHours = unixHour * vpStartHours;
    var now            = new Date(Date.now());
    var nowYear        = now.getFullYear();
    var nowMonth       = now.getMonth();
    var nowDay         = now.getDate();
    var nowHours       = now.getHours();
    var nowMinutes     = now.getMinutes();
    var vehicleShapeH  = rowHeight-10;
    //Variables (to be used)
    var stationHeight;
    var deliveries=[];
    var workflowsFakeData=[];
    var startingX;
    var duration, variation, variationMinutes;
    var yDeliveryScale;
    var stationCounts =[];
    var stationStackedCount=[];
    var stationStacked=[];
    var panBounds;

    var customShapes = { 
      lBook: function(r) {
        var points = [ [0,r], [0,-r], [r,0], [0,r]];
        return d3.svg.line()(points);
      },
      rBook: function(r) {
        var points = [ [0,r], [0,-r], [-r,0], [0,r]];
        return d3.svg.line()(points);
      },
      // io: function(height, width) {
      //   var points = [ [0,height], [width*.2,0], [width,0], [width*.8,height], [0,height] ]
      //   return d3.svg.line()(points);
      // }
    }

    //scales
    var xScale = d3.time.scale.utc()
          .domain([+new Date(nowYear, nowMonth, nowDay-1,12),                +new Date(nowYear, nowMonth, nowDay+1,12)])
          .range( [0,                                     xAxisWidth]);

    var yDeliveryScale = d3.scale.linear()
          .domain([1,7])
          .range([1+rowHeight,7*rowHeight]);

    var viewportScale = d3.time.scale.utc()
          .domain([+new Date(nowYear, nowMonth, nowDay-1,12)+unixStartHours,  +new Date(nowYear, nowMonth, nowDay+1,12)-unixStartHours])
          .range( [0,                                     -1*xAxisWidth+outerWidth]);

    startingX = viewportScale(new Date(nowYear,nowMonth,nowDay,nowHours,nowMinutes));

    var xAxis = d3.svg.axis()
          .ticks(d3.time.hours, 1)
          .tickFormat(d3.time.format('%H'))
          .scale(xScale);

    //Create Data
    var workflowsFakeData = generateWorkflows(startOfDayHour);

    var deliveries = d3.nest()  //group by delivery
          .key(function(d) { return d.delivery; })
          .entries(workflowsFakeData);

    deliveries.forEach(function(delivery) {
      var type = Math.random();
      if (type <.5){
        delivery.vehicleType = 'icn-vehicle-bulk.png';
      } else if(type < .75){
        delivery.vehicleType = 'icn-vehicle-common.png';
      } else {
        delivery.vehicleType = 'icn-vehicle-noncommon.png';
      }
    });

    //interactivity
    var xAxisTranslation = d3.behavior.zoom()
          .scaleExtent([1, 1])
          .translate([startingX,0])
          .on("zoom", moveXAxis);

    //Structure
    var svg = d3.select("body").append("svg")
          .attr("width",  outerWidth)
          .attr("height", outerHeight)
          .call(xAxisTranslation);;

        //gradients
        var svgDefs = svg.append('defs');
            var aheadGradient = svgDefs.append('linearGradient')
                .attr('id', 'aheadGradient');
            aheadGradient.append('stop')
                .attr('class', 'color-ahead-left')
                .attr('offset', '0');
            aheadGradient.append('stop')
                .attr('class', 'color-ahead-right')
                .attr('offset', '1');
            var lateGradient = svgDefs.append('linearGradient')
                .attr('id', 'lateGradient');
            lateGradient.append('stop')
                .attr('class', 'color-late-left')
                .attr('offset', '0');
            lateGradient.append('stop')
                .attr('class', 'color-late-right')
                .attr('offset', '1');
            var onTimeGradient = svgDefs.append('linearGradient')
                .attr('id', 'onTimeGradient');
            onTimeGradient.append('stop')
                .attr('class', 'color-onTime-left')
                .attr('offset', '0');
            onTimeGradient.append('stop')
                .attr('class', 'color-onTime-right')
                .attr('offset', '1');



        var stationsGroup = svg.append("g")
              .attr("class", "stations")
              .attr('transform', 'translate(' + 0 + "," + 0 + ')')

        var g = svg.append("g")
              .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

            var deliveriesGroup = g.append("g")
                  .attr("class", "deliveries")
                  .attr('transform', 'translate(' + startingX + "," + 0 + ')');

                var yAxisGroup = deliveriesGroup.append("g")
                      .attr("class", "y axis");

            var xAxisGroup = g.append("g")
                  .attr("class", "x axis")
                  .attr('transform', 'translate(' + startingX + "," +  innerHeight + ')');

    

    render(deliveries);
    // setInterval(render(deliveries), 100);
    // setInterval(function() {render(deliveries),10000});
    window.onresize = resize;



    //utility
    function render(data){
      console.log('render');
      //data manipulation
      data                    = updateCurrentStationCalc(data);
      var stationCounts       = stationCountCalc(data);                                         // Gets the number of deliveries for every station
      var stationStackedCount = stationStackedCountCalc(stationCounts);
      var stationStacked      = stationStackedCalc(stationCounts,stationStackedCount,stations);

      stationHeight = (stationStacked[stationStackedCount.length-1].y0*rowHeight) +
                      (stationStacked[stationStackedCount.length-1].y * rowHeight);
      panBounds = { top:    0,
                    right:  0,
                    bottom: (-1*stationHeight) + innerHeight - xAxisHeight,
                    left:   (-1*xAxisWidth) + outerWidth};

      data = data.sort(compare);

      var data = d3.nest() // groupByStation
          .key(function(d) { return d.currentStation; })
          .sortValues(function(a,b) { return b.values[0].endTime - a.values[0].endTime; })
          .entries(data);

      data = stackDeliveriesCalc(stationStackedCount,data); // set the yIndex for every delivery (make sure )

      // Setup stations overlay and text
      var stationsSelectAll = stationsGroup.selectAll(".station").data(stationStacked);
      stationsSelectAll.enter().append("g").attr("class", "station"); // stations should never exit

      stationsSelectAll.append("rect")
          .attr("x", function(d,i) { return 0;})
          .attr("y", function(d,i) { return d.y0*rowHeight + (rowHeight/2);})
          .attr("width",innerWidth)
          .attr("height", function(d,i) { return d.y*rowHeight;})

      stationsSelectAll.append("text")
          .attr("x", function(d,i) { return stationTextPadding.left;})
          .attr("y", function(d,i) { return d.y0*rowHeight + (rowHeight/2) + stationTextHeight + stationTextPadding.top;})
          .text(function(d,i){return d.name})
          .attr("class","name")
          .attr("font-size", stationTextHeight + "px");

      // Setup axii
      xAxisGroup.call(xAxis);
      yAxisGroup.append("line")
          .attr("class","yAxis")
          .attr("x1", xScale(now))
          .attr("y1", margin.top)
          .attr("x2", xScale(now))
          .attr("y2", Math.max(stationHeight+ xAxisHeight, outerHeight));


      // Setup Stations
      var stationsSelectAll2 = deliveriesGroup.selectAll(".station").data(data);
      stationsSelectAll2.enter().append("g").attr("class", "station");
      stationsSelectAll2.exit().remove();

      // Setup Deliveries
      var deliveriesSelectAll = stationsSelectAll2.selectAll(".delivery").data(function(d){
        return d.values;
      });
      var deliveriesSelectAllG = deliveriesSelectAll.enter().append("g").attr("class", "delivery");
      deliveriesSelectAllG
          .attr('transform', function(d){
            return 'translate(' + 0 + "," + yDeliveryScale(d.yIndex+1)+ ')';
          });

      

      // Setup Workflows
      var workflowsSelectAll = deliveriesSelectAllG.selectAll(".workflow").data(function(d){
        return d.values;
      });
      var workflowsSelectAllG = workflowsSelectAll.enter().append("g");
      workflowsSelectAll.exit().remove();

      workflowsSelectAll
          .each(function(d){
            var header = d3.select(this);
            if(d.startTime <now && now < d.endTime)  //Workflow straddles now
            {
              console.log(d);
              var state = Math.random();

              //leftside of now
              header.append("line")
                  .attr("x1", function(d,i) { return xScale(d.startTime); })
                  .attr("y1", function(d,i) { return 0;})
                  .attr("x2", function(d,i) { return xScale(now); })
                  .attr("y2", function(d,i) { return 0;})
                  .attr("class", function(d){
                    if (d.startTime <now) {
                      if(state<.25){
                        return "workflow ahead" 
                      } else if (state < .5){
                        return "workflow late"
                      } else {
                        return "workflow"
                      }
                    } else {
                      return "workflow notReached";
                    }
                  });

              header.append("svg:path")
                  .attr("d", function(d) { return customShapes['lBook'](4);})
                  .attr("class", function(d){
                    if(d.startTime < now){
                      return "bookEnd notReached";
                    }
                  })
                  .attr("transform", function(d) {
                    return "translate(" + xScale(d.startTime) + "," + 0 + ")"
                  });;


              //on right side of now
              header.append("line")
                  .style("stroke-dasharray", ("2, 2"))
                  .style("stroke-width", 4)
                  .attr("x1", function(d,i) { return xScale(now); })
                  .attr("y1", function(d,i) { return 0;})
                  .attr("x2", function(d,i) { return xScale(d.endTime); })
                  .attr("y2", function(d,i) { return .001;})//IMPORTANT  if its flat its not displayed
                  // .style("stroke", function(d) { return aheadGradient(d.); })
                  // .attr('stroke', 'url(#mainGradient)');
                  .attr("class", function(d){
                    if(state<.25){
                      return "workflow aheadGradient" 
                    } else if (state < .5){
                      return "workflow lateGradient"
                    } else {
                      return "workflow onTimeGradient"
                    }
                  });



            } else {  //workflow outside of now

              header.append("line")
                  .attr("x1", function(d,i) { return xScale(d.startTime); })
                  .attr("y1", function(d,i) { return 0;})
                  .attr("x2", function(d,i) { return xScale(d.endTime); })
                  .attr("y2", function(d,i) { return 0;})
                  .attr("class", function(d){
                    if (d.startTime <now) {
                      var state = Math.random();
                      if(state<.25){
                        return "workflow ahead" 
                      } else if (state < .5){
                        return "workflow late"
                      } else {
                        return "workflow"
                      }
                    } else {
                      return "workflow notReached";
                    }
                  });


              header.append("svg:path")
                  .attr("d", function(d) { return customShapes['lBook'](4);})
                  .attr("class", function(d){
                    if(d.startTime < now){
                      return "bookEnd notReached";
                    }
                  })
                  .attr("transform", function(d) {
                    return "translate(" + xScale(d.startTime) + "," + 0 + ")"
                  });;

              header.append("svg:path")
                  .attr("d", function(d) { console.log('bookend');return customShapes['rBook'](4);})
                  .attr("class", function(d){
                    if(d.endTime < now){
                      return "bookEnd notReached";
                    }
                  })
                  .attr("transform", function(d) {
                    return "translate(" + xScale(d.endTime) + "," + 0 + ")"
                  });;


            }
            // console.log(header);
          });


      var vehicleIconsG = deliveriesSelectAllG.append("g");
      //setup Vehicle Icons
      vehicleIconsG.append("image")
          .attr("xlink:href",function(i){
              return "img/" + i.vehicleType
          })
          .attr("height", vehicleShapeH)
          .attr("width", vehicleShapeH)
          .attr("x",-1*(vehicleShapeH/2))
          .attr("y",-1*(vehicleShapeH/2))
          .attr("class", "truckIconDiamond")
          .attr("transform", function(d) {
              return "translate(" + xScale(now) + "," + 0 + ")"
            });;
      
    }

    function resize() {
      outerWidth  = document.documentElement.clientWidth;
      outerHeight = document.documentElement.clientHeight;
      console.log(outerWidth);
      console.log(outerHeight);
      innerWidth     = outerWidth   - margin.left - margin.right;
      innerHeight    = outerHeight  - margin.top  - margin.bottom;
      svg.remove();
      svg = d3.select("body").append("svg")
        .attr("width",  outerWidth)
        .attr("height", outerHeight)
        .call(xAxisTranslation);;

        stationsGroup = svg.append("g")
            .attr("class", "stations")
            .attr('transform', 'translate(' + 0 + "," + 0 + ')')

        g = svg.append("g")
            .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

            deliveriesGroup = g.append("g")
                .attr("class", "deliveries")
                .attr('transform', 'translate(' + startingX + "," + 0 + ')');

                yAxisGroup = deliveriesGroup.append("g")
                  .attr("class", "y axis");

            xAxisGroup = g.append("g")
                .attr("class", "x axis")
                .attr('transform', 'translate(' + startingX + "," +  innerHeight + ')');

      svg.attr("width", outerWidth).attr("height", outerHeight);
      render(deliveries);

      deliveriesGroup.attr("transform", "translate(" + [startingX,0] + ")scale(1)");
      stationsGroup.attr("transform", "translate(" + [0,0] + ")scale(1)");
      xAxisGroup.attr("transform", "translate(" + [startingX,innerHeight] + ")scale(1)");
    }

    function moveXAxis(a,b) {
      var eventxTranslation = d3.event.translate[0];
      var eventyTranslation = d3.event.translate[1];

      deliveriesGroup.attr("transform", "translate(" + [eventxTranslation,eventyTranslation] + ")scale(1)");
      stationsGroup.attr("transform", "translate(" + [0,eventyTranslation] + ")scale(1)");
      xAxisGroup.attr("transform", "translate(" + [eventxTranslation,innerHeight] + ")scale(1)");

      if (panBounds.left > eventxTranslation || eventxTranslation > panBounds.right || eventyTranslation > panBounds.top || eventyTranslation < panBounds.bottom ) {
        var maxShiftFromTop = stationHeight>outerHeight?panBounds.bottom:0;
        var translation = [
          Math.max(Math.min(eventxTranslation, panBounds.right),  panBounds.left),
          Math.max(Math.min(eventyTranslation, panBounds.top),    maxShiftFromTop)
        ];

        deliveriesGroup.attr("transform", "translate(" + [translation[0],translation[1]] + ")scale(1)");
        stationsGroup.attr("transform", "translate(" + [0,translation[1]] + ")scale(1)");
        xAxisGroup.attr("transform", "translate(" + [translation[0],innerHeight] + ")scale(1)");
        xAxisTranslation.translate(translation);
      }
    }


    function updateCurrentStationCalc(data){//update every delivery w/ its current station
      var workflow;
      var currentStation = 0;
      var isCurrentUpdated = false;
      var now = new Date(Date.now());

      //assums workflows are in ascending order
      for (var i = 0; i < data.length; i++) {
        currentStation = 0;
        isCurrentUpdated = false;
        for (var j = 0; j < data[i].values.length; j++) {
           workflow = data[i].values[j];

          // debugger;
          if(!isCurrentUpdated){
            if(now < workflow.endTime){
              currentStation = workflow.station;
              isCurrentUpdated = true;
            }
          }

        }

        if(currentStation == 1){
          var firstWorkflowOfDelivery = data[i].values[0];

          if (firstWorkflowOfDelivery.startTime > now) {
            currentStation = 0; // first station
          };
        }

        if(currentStation == 0){
          var lastWorkflowOfDelivery = data[i].values[data[i].values.length-1];

          if (lastWorkflowOfDelivery.endTime < now) {
            currentStation = 6; // last station
          };
        }
        data[i].currentStation = currentStation;


      };
      return data;
    }

    function stationCountCalc(data){ // [7, 5, 5, 1, 4, 1, 1, 1] Gets the number of deliveries for every station
      var stationCounts =[0,0,0,0,0,0,0];      //[7, 5, 5, 1, 4, 1, 1, 1]


      for(var i = 0;i<data.length;i++){
        stationCounts[data[i].currentStation]++;
      }
      for (var i = 0; i < stationCounts.length; i++) { //make sure they have at least 1
        stationCounts[i] = stationCounts[i] || 1;
      };

      return stationCounts;
    }

    function stationStackedCountCalc(stationCounts){ //[7, 12, 17, 18, 22, 23, 24, 25]
      var stationStackedCount=[0,0,0,0,0,0,0];

      stationStackedCount[0] = stationCounts[0];
      for (var i = 1; i < stationCounts.length; i++) {
        stationStackedCount[i] = stationStackedCount[i-1]+ stationCounts[i];
      };

      return stationStackedCount;
    }

    function stationStackedCalc(stationCounts,stationStackedCount,stations){//stacks each station with its y0 index and height
      var stationStacked=[];                     //[Object(name:EnRoute, y:7,y0:0),Object...]

      stationStacked[0]={
                          "y0":0,
                          "y":stationCounts[0],
                          "name": stations[0]}

      //this needs to factor in zooming, or add it to zoom section
      for (var i = 1; i < stationStackedCount.length; i++) {
        stationStacked[i] = {
                              "y0":stationStackedCount[i-1],
                              "y":stationCounts[i],
                              "name":stations[i]
                            };
      };
      return stationStacked
    }

    function stackDeliveriesCalc(stationStackedCount,stationData) { //we set the starting yIndex. of each Delivery.  We have to account for stations w/o a delivery

      for (var i = 0; i < stationData.length; i++) {
        for (var j = 0; j < stationData[i].values.length; j++) {
            if(stationData[i].key == 0){
              stationData[i].values[j].yIndex = j;
            }else {
              stationData[i].values[j].yIndex = stationStackedCount[stationData[i].key-1] + j;
            }
        }
      }

      return stationData;
    }

    function compare(a,b) {
      if (a.currentStation < b.currentStation)
        return -1;
      else if (a.currentStation > b.currentStation)
        return 1;
      else
        return 0;
    }

    function isTimeBetweenTime(time, start,end){
      return start <= time && time <= end;
    }

    function generateShapes(){
      d3.xml("img/icn-vehicle-common.svg", "image/svg+xml", function(error, xml) {
        if (error) throw error;
        console.log(xml.documentElement);
        return xml.documentElement;
      });
    }

    function generateWorkflows(startOfDayHour){
      var workflows=[];
      for(var i = 21; i > 0; i--){
        variation =        Math.random() * 1;
        variationMinutes = Math.random() * 60;

        workflows.push({  startTime: new Date(nowYear, nowMonth, nowDay,startOfDayHour+(i*0.2),28),
                          endTime:   new Date(nowYear, nowMonth, nowDay,startOfDayHour+(i*0.2),48),
                          delivery: i,
                          station:Math.round(1),
                        });

        workflows.push({  startTime: new Date(nowYear, nowMonth, nowDay,startOfDayHour+(i*0.2),56),
                          endTime:   new Date(nowYear, nowMonth, nowDay,startOfDayHour+(i*0.2)+1,40),
                          delivery: i,
                          station:Math.round(2),
                        });

        workflows.push({  startTime: new Date(nowYear, nowMonth, nowDay,startOfDayHour+(i*0.2)+1, 44),
                          endTime:   new Date(nowYear, nowMonth, nowDay,startOfDayHour+(i*0.2)+2, 20),
                          delivery: i,
                          station:Math.round(3),
                        });

        workflows.push({  startTime: new Date(nowYear, nowMonth, nowDay,startOfDayHour+(i*0.2)+2,22),
                          endTime:   new Date(nowYear, nowMonth, nowDay,startOfDayHour+(i*0.2)+4,12),
                          delivery: i,
                          station:Math.round(4),
                        });

        workflows.push({  startTime: new Date(nowYear, nowMonth, nowDay,startOfDayHour+(i*0.2)+4,15),
                          endTime:   new Date(nowYear, nowMonth, nowDay,startOfDayHour+(i*0.2)+4,40),
                          delivery: i,
                          station:Math.round(5),
                        });

      }
      return workflows;
    }

    
  </script>
</html>

