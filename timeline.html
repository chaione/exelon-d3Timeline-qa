<!DOCTYPE html>
<html>
  <meta charset="utf-8">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="viewport" content="width=device-width, minimum-scale=1.0">

  <!-- http://curran.github.io/screencasts/splittingCharts/examples/viewer/#/17 -->
  <!-- http://bl.ocks.org/mbostock/3885705 transitions-->
  <!-- <meta name="viewport" content="minimal-ui"> -->
  <link rel="stylesheet" type="text/css" href="styles.css">

  <body>
  </body>


  <script src="http://d3js.org/d3.v3.js"></script>
  <script>
    "use strict";
    console.log('Version 03 15 2016');

    //safari rotate bug fix
    (function(doc) {

      var addEvent = 'addEventListener',
          type = 'gesturestart',
          qsa = 'querySelectorAll',
          scales = [1, 1],
          meta = qsa in doc ? doc[qsa]('meta[name=viewport]') : [];

      function fix() {
        meta.content = 'width=device-width,minimum-scale=' + scales[0] + ',maximum-scale=' + scales[1];
        doc.removeEventListener(type, fix, true);
      }

      if ((meta = meta[meta.length - 1]) && addEvent in doc) {
        fix();
        scales = [1, 1];
        doc[addEvent](type, fix, true);
      }

    }(document));
    
    //User Defined Variables
    var rowHeight   = 45;
    var xAxisHeight = 30;
    var xAxisWidth  = 4500;
    var stationTextHeight = 20;
    var stationTextPadding = {top: 10, right: 0, bottom: 0, left: 10};

    var margin      = {top: 0, right: 0, bottom: 30, left: 0};
    var outerWidth  = document.documentElement.clientWidth;
    var outerHeight = document.documentElement.clientHeight;
    console.log(outerWidth);
    console.log(outerHeight);
    var startOfDayHour = 6; //used for fake data
    var stations =   {
                      0:"En Route",
                      1:"Sierra One",
                      2:"Stinger Gate",
                      3:"Sally Port",
                      4:"Warehouse",
                      5:"PA",
                      6:"Exit"
                    }

    //Calculated Variables
    var innerWidth     = outerWidth   - margin.left - margin.right;
    var innerHeight    = outerHeight  - margin.top  - margin.bottom;
    var unixHour       = 1000*60*60;
    var unixMinute     = 1000*60;
    var vpStartHours   = (outerWidth/2)/(xAxisWidth/24);  //startHours is the time where the Viewport's (middle of screen) y axis naturally rests.  Its time in hours.
    var unixStartHours = unixHour * vpStartHours;
    var now            = new Date(Date.now());
    var nowYear        = now.getFullYear();
    var nowMonth       = now.getMonth();
    var nowDay         = now.getDate();
    var nowHours       = now.getHours();
    var nowMinutes     = now.getMinutes();
    var vehicleShapeH  = rowHeight-10;
    //Variables (to be used)
    var stationCounts =[];
    var stationStackedCount=[];
    var stationStacked=[];
    var stationHeight;
    var deliveries=[];
    var workflowsFakeData=[];
    var startingX;
    var duration, variation, variationMinutes;
    var yDeliveryScale;
    
    var panBounds;

    var customShapes = { 
      lBook: function(r) {
        var points = [ [0,r], [0,-r], [r,0], [0,r]];
        return d3.svg.line()(points);
      },
      rBook: function(r) {
        var points = [ [0,r], [0,-r], [-r,0], [0,r]];
        return d3.svg.line()(points);
      }
    }

    //scales
    var xScale = d3.time.scale.utc()
          .domain([+new Date(nowYear, nowMonth, nowDay-1,12),                +new Date(nowYear, nowMonth, nowDay+1,12)])
          .range( [0,                                     xAxisWidth]);

    var yDeliveryScale = d3.scale.linear()
          .domain([1,7])
          .range([1+rowHeight,7*rowHeight]);

    var viewportScale = d3.time.scale.utc()
          .domain([+new Date(nowYear, nowMonth, nowDay-1,12)+unixStartHours,  +new Date(nowYear, nowMonth, nowDay+1,12)-unixStartHours])
          .range( [0,                                     -1*xAxisWidth+outerWidth]);

    startingX = viewportScale(new Date(nowYear,nowMonth,nowDay,nowHours,nowMinutes));

    var xAxis = d3.svg.axis()
          .ticks(d3.time.hours, 1)
          .tickFormat(d3.time.format('%H'))
          .scale(xScale);

    //Create Data
    var workflowsFakeData = generateWorkflows(startOfDayHour);

    var deliveries = d3.nest()  //group by delivery
          .key(function(d) { return d.delivery; })
          .entries(workflowsFakeData);

    deliveries.forEach(function(delivery) {
      var type = Math.random();
      if (type <.5){
        delivery.vehicleType = 'icn-vehicle-bulk.png';
      } else if(type < .75){
        delivery.vehicleType = 'icn-vehicle-common.png';
      } else {
        delivery.vehicleType = 'icn-vehicle-noncommon.png';
      }
    });

    //interactivity
    var xAxisTranslation = d3.behavior.zoom()
          .scaleExtent([1, 1])
          .translate([startingX,0])
          .on("zoom", moveXAxis);

    //Structure
    var svg = d3.select("body").append("svg")
          .attr("width",  outerWidth)
          .attr("height", outerHeight)
          .call(xAxisTranslation);;

        //gradients
        var svgDefs = svg.append('defs');
            var maskingGradient = svgDefs.append('linearGradient')
                .attr('id', 'maskingGradient')
                .attr("x1", "0%")
                .attr("y1", "100%")
                .attr("x2", "0%")
                .attr("y2", "0%");
            maskingGradient.append('stop')
                .attr('class', 'color-maskingGradient-top')
                .attr('offset', '0');
            maskingGradient.append('stop')
                .attr('class', 'color-maskingGradient-bottom')
                .attr('offset', '.15');
            maskingGradient.append('stop')
                .attr('class', 'color-maskingGradient-bottom')
                .attr('offset', '1')
                .attr('stop-opacity', '0');
            var aheadGradient = svgDefs.append('linearGradient')
                .attr('id', 'aheadGradient');
            aheadGradient.append('stop')
                .attr('class', 'color-ahead-left')
                .attr('offset', '0');
            aheadGradient.append('stop')
                .attr('class', 'color-ahead-right')
                .attr('offset', '1');
            var lateGradient = svgDefs.append('linearGradient')
                .attr('id', 'lateGradient');
            lateGradient.append('stop')
                .attr('class', 'color-late-left')
                .attr('offset', '0');
            lateGradient.append('stop')
                .attr('class', 'color-late-right')
                .attr('offset', '1');
            var onTimeGradient = svgDefs.append('linearGradient')
                .attr('id', 'onTimeGradient');
            onTimeGradient.append('stop')
                .attr('class', 'color-onTime-left')
                .attr('offset', '0');
            onTimeGradient.append('stop')
                .attr('class', 'color-onTime-right')
                .attr('offset', '1');



        var stationsGroup = svg.append("g")
              .attr("class", "stations")
              .attr('transform', 'translate(' + 0 + "," + 0 + ')')

        var g = svg.append("g")
              .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

            var deliveriesGroup = g.append("g")
                  .attr("class", "deliveries")
                  .attr('transform', 'translate(' + startingX + "," + 0 + ')');

                var yAxisGroup = deliveriesGroup.append("g")
                      .attr("class", "y axis");

            var xAxisMask = g.append("rect")
                  .attr("x", 0)
                  .attr("y", 0)
                  .attr("width", outerWidth)
                  .attr("height", xAxisHeight*3)
                  .attr("class","maskingGradient");

            var xAxisGroup = g.append("g")
                  .attr("class", "x axis ")
                  .attr('transform', 'translate(' + startingX + "," +  innerHeight + ')');

         // svg.append('rect')
            
                 
    

    resize();
    // setInterval(render(deliveries), 100);
    // setInterval(function() {render(deliveries),10000});
    window.onresize = resize;



    //utility
    function render(data){
      console.log('render');
      outerWidth  = document.documentElement.clientWidth;
      outerHeight = document.documentElement.clientHeight;
      innerWidth     = outerWidth   - margin.left - margin.right;
      innerHeight    = outerHeight  - margin.top  - margin.bottom;
      

      stationHeight = (stationStacked[stationStackedCount.length-1].y0*rowHeight) +
                      (stationStacked[stationStackedCount.length-1].y * rowHeight);
      panBounds = { top:    0,
                    right:  0,
                    bottom: (-1*stationHeight) + innerHeight - xAxisHeight,
                    left:   (-1*xAxisWidth) + outerWidth};

      
      //clear it out
      svg.remove();
            svg = d3.select("body").append("svg")
              .attr("width",  outerWidth)
              .attr("height", outerHeight)
              .call(xAxisTranslation);;
              stationsGroup = svg.append("g")
                  .attr("class", "stations")
                  .attr('transform', 'translate(' + 0 + "," + 0 + ')')
              g = svg.append("g")
                  .attr("transform", "translate(" + margin.left + "," + margin.top + ")");
                  deliveriesGroup = g.append("g")
                      .attr("class", "deliveries")
                      .attr('transform', 'translate(' + startingX + "," + 0 + ')');
                      yAxisGroup = deliveriesGroup.append("g")
                        .attr("class", "y axis");
                  xAxisGroup = g.append("g")
                      .attr("class", "x axis")
                      .attr('transform', 'translate(' + startingX + "," +  innerHeight + ')');
            var svgDefs = svg.append('defs');
                var maskingGradient = svgDefs.append('linearGradient')
                    .attr('id', 'maskingGradient')
                    .attr("x1", "0%")
                    .attr("y1", "100%")
                    .attr("x2", "0%")
                    .attr("y2", "0%");
                maskingGradient.append('stop')
                    .attr('class', 'color-maskingGradient-top')
                    .attr('offset', '0');
                maskingGradient.append('stop')
                    .attr('class', 'color-maskingGradient-bottom')
                    .attr('offset', '.15');
                maskingGradient.append('stop')
                    .attr('class', 'color-maskingGradient-bottom')
                    .attr('offset', '1')
                    .attr('stop-opacity', '0');
                var aheadGradient = svgDefs.append('linearGradient')
                    .attr('id', 'aheadGradient');
                aheadGradient.append('stop')
                    .attr('class', 'color-ahead-left')
                    .attr('offset', '0');
                aheadGradient.append('stop')
                    .attr('class', 'color-ahead-right')
                    .attr('offset', '1');
                var lateGradient = svgDefs.append('linearGradient')
                    .attr('id', 'lateGradient');
                lateGradient.append('stop')
                    .attr('class', 'color-late-left')
                    .attr('offset', '0');
                lateGradient.append('stop')
                    .attr('class', 'color-late-right')
                    .attr('offset', '1');
                var onTimeGradient = svgDefs.append('linearGradient')
                    .attr('id', 'onTimeGradient');
                onTimeGradient.append('stop')
                    .attr('class', 'color-onTime-left')
                    .attr('offset', '0');
                onTimeGradient.append('stop')
                    .attr('class', 'color-onTime-right')
                    .attr('offset', '1');

      svg
          .attr("width", outerWidth)
          .attr("height", outerHeight);

      // stationsGroup   .attr('transform', 'translate(' + 0 + "," + 0 + ')')
      // deliveriesGroup .attr("transform", "translate(" + [startingX,0] + ")scale(1)");
      xAxisGroup      .attr('transform', 'translate(' + startingX + "," +  innerHeight + ')');
      xAxisMask       .attr('transform', 'translate(' + 0 + "," +  (outerHeight - (xAxisHeight*3)) + ')');
      // Setup stations overlay and text
      var stationsLabelSelectAll = stationsGroup.selectAll(".station").data(stationStacked);
      var stationsLabelSelectAllG = stationsLabelSelectAll.enter().append("g").attr("class", "station"); // stations should never exit

      stationsLabelSelectAllG.append("rect").attr("class","stationRect");
      var stationsLabelStationRectSelectAll = stationsLabelSelectAll.selectAll(".stationRect");

      stationsLabelStationRectSelectAll
          .attr("x", function(d,i) { return 0;})
          .attr("y", function(d,i) { return d.y0*rowHeight + (rowHeight/2);})
          .attr("width",innerWidth)
          .attr("height", function(d,i) {return d.y*rowHeight;})

      stationsLabelSelectAllG.append("text")
          .attr("x", function(d,i) { return stationTextPadding.left;})
          .attr("y", function(d,i) { return d.y0*rowHeight + (rowHeight/2) + stationTextHeight + stationTextPadding.top;})
          .text(function(d,i){return d.name})
          .attr("class","name")
          .attr("font-size", stationTextHeight + "px");

      // Setup axii
      xAxisGroup.call(xAxis);
      yAxisGroup.append("line")
          .attr("class","yAxis")
          .attr("x1", xScale(now))
          .attr("y1", margin.top)
          .attr("x2", xScale(now))
          .attr("y2", Math.max(stationHeight+ xAxisHeight, outerHeight));

      // Setup Stations
      var stationsSelectAll2 = deliveriesGroup.selectAll(".station").data(data);
      stationsSelectAll2.enter().append("g").attr("class", "station");
      stationsSelectAll2.exit().remove();

      // Setup Deliveries
      var deliveriesSelectAll = stationsSelectAll2.selectAll(".delivery").data(function(d){
        return d.values;
      });
      var deliveriesSelectAllG = deliveriesSelectAll.enter().append("g").attr("class", "delivery");
      deliveriesSelectAllG
          .attr('transform', function(d){
            return 'translate(' + 0 + "," + yDeliveryScale(d.yIndex+1)+ ')';
          });

      // Setup Workflows
      var workflowsSelectAll = deliveriesSelectAllG.selectAll(".workflow").data(function(d){
        return d.values;
      });
      var workflowsSelectAllG = workflowsSelectAll.enter().append("g");
      workflowsSelectAll.exit().remove();
      var workflowSelectAll5 = workflowsSelectAll.selectAll(".workflow");
      workflowsSelectAllG
          .each(function(d){
            var header = d3.select(this);
            if(d.startTime <now && now < d.endTime)  //current workflow
            {
              var state = Math.random();

              //leftside of now
              header.append("line")
                  .attr("x1", function(d,i) { return xScale(d.startTime); })
                  .attr("y1", function(d,i) { return 0;})
                  .attr("x2", function(d,i) { return xScale(now); })
                  .attr("y2", function(d,i) { return 0;})
                  .attr("class", function(d){
                    if (d.startTime <now) {
                      if(state<.25){
                        return "workflow ahead" 
                      } else if (state < .5){
                        return "workflow late"
                      } else {
                        return "workflow"
                      }
                    } else {
                      return "workflow notReached";
                    }
                  });

              header.append("svg:path")
                  .attr("d", function(d) { return customShapes['lBook'](4);})
                  .attr("class", function(d){
                    if(d.startTime < now){
                      return "bookEnd notReached";
                    }
                  })
                  .attr("transform", function(d) {
                    return "translate(" + xScale(d.startTime) + "," + 0 + ")"
                  });;


              //on right side of now
              header.append("line")
                  .attr("x1", function(d,i) { return xScale(now); })
                  .attr("y1", function(d,i) { return 0;})
                  .attr("x2", function(d,i) { return xScale(d.endTime); })
                  .attr("y2", function(d,i) { return .001;})//IMPORTANT  if its flat its not displayed
                  .style("stroke-dasharray", ("2, 2"))
                  .style("stroke-width", 4)
                  .attr("class", function(d){
                    if(state<.25){
                      return "workflow aheadGradient" 
                    } else if (state < .5){
                      return "workflow lateGradient"
                    } else {
                      return "workflow onTimeGradient"
                    }
                  });

            } else {  //not active workflow

              header.append("line")
                  .attr("x1", function(d,i) { return xScale(d.startTime); })
                  .attr("y1", function(d,i) { return 0;})
                  .attr("x2", function(d,i) { return xScale(d.endTime); })
                  .attr("y2", function(d,i) { return 0;})
                  .attr("class", function(d){
                    if (d.startTime <now) {
                      var state = Math.random();
                      if(state<.25){
                        return "workflow ahead" 
                      } else if (state < .5){
                        return "workflow late"
                      } else {
                        return "workflow"
                      }
                    } else {
                      return "workflow notReached";
                    }
                  });


              header.append("svg:path")
                  .attr("d", function(d) { return customShapes['lBook'](4);})
                  .attr("class", function(d){
                    if(d.startTime < now){
                      return "bookEnd notReached";
                    }
                  })
                  .attr("transform", function(d) {
                    return "translate(" + xScale(d.startTime) + "," + 0 + ")"
                  });;

              header.append("svg:path")
                  .attr("d", function(d) { return customShapes['rBook'](4);})
                  .attr("class", function(d){
                    if(d.endTime < now){
                      return "bookEnd notReached";
                    }
                  })
                  .attr("transform", function(d) {
                    return "translate(" + xScale(d.endTime) + "," + 0 + ")"
                  });;

            }
          });


      var vehicleIconsG = deliveriesSelectAllG.append("g");
      //setup Vehicle Icons
      vehicleIconsG.append("image")
          .attr("xlink:href",function(i){
              return "img/" + i.vehicleType
          })
          .attr("height", vehicleShapeH)
          .attr("width", vehicleShapeH)
          .attr("x",-1*(vehicleShapeH/2))
          .attr("y",-1*(vehicleShapeH/2))
          .attr("class", "truckIconDiamond")
          .attr("transform", function(d) {
              return "translate(" + xScale(now) + "," + 0 + ")"
            });;
    }

    function resize() {
      console.log('resize');
      var data = deliveries;
      data                = updateCurrentStationCalc(data);
      stationCounts       = stationCountCalc(data);                                         // Gets the number of deliveries for every station
      stationStackedCount = stationStackedCountCalc(stationCounts);
      stationStacked      = stationStackedCalc(stationCounts,stationStackedCount,stations);
      data = data.sort(compare);

      data = d3.nest() // groupByStation
          .key(function(d) { return d.currentStation; })
          .sortValues(function(a,b) { return b.values[0].endTime - a.values[0].endTime; })
          .entries(data);
      data = stackDeliveriesCalc(stationStackedCount,data);

      render(data);
    }

    function moveXAxis(a,b) {
      var eventxTranslation = d3.event.translate[0];
      var eventyTranslation = d3.event.translate[1];

      deliveriesGroup.attr("transform", "translate(" + [eventxTranslation,eventyTranslation] + ")scale(1)");
      stationsGroup.attr("transform", "translate(" + [0,eventyTranslation] + ")scale(1)");
      xAxisGroup.attr("transform", "translate(" + [eventxTranslation,innerHeight] + ")scale(1)");

      if (panBounds.left > eventxTranslation || eventxTranslation > panBounds.right || eventyTranslation > panBounds.top || eventyTranslation < panBounds.bottom ) {
        var maxShiftFromTop = stationHeight>outerHeight?panBounds.bottom:0;
        var translation = [
          Math.max(Math.min(eventxTranslation, panBounds.right),  panBounds.left),
          Math.max(Math.min(eventyTranslation, panBounds.top),    maxShiftFromTop)
        ];
        deliveriesGroup.attr("transform", "translate(" + [translation[0],translation[1]] + ")scale(1)");
        stationsGroup.attr("transform", "translate(" + [0,translation[1]] + ")scale(1)");
        xAxisGroup.attr("transform", "translate(" + [translation[0],innerHeight] + ")scale(1)");
        xAxisTranslation.translate(translation);
      }
    }


    function updateCurrentStationCalc(data){//update every delivery w/ its current station
      var workflow;
      var currentStation = 0;
      var isCurrentUpdated = false;
      var now = new Date(Date.now());

      //assums workflows are in ascending order
      for (var i = 0; i < data.length; i++) {
        currentStation = 0;
        isCurrentUpdated = false;
        for (var j = 0; j < data[i].values.length; j++) {
           workflow = data[i].values[j];

          // debugger;
          if(!isCurrentUpdated){
            if(now < workflow.endTime){
              currentStation = workflow.station;
              isCurrentUpdated = true;
            }
          }

        }

        if(currentStation == 1){
          var firstWorkflowOfDelivery = data[i].values[0];

          if (firstWorkflowOfDelivery.startTime > now) {
            currentStation = 0; // first station
          };
        }

        if(currentStation == 0){
          var lastWorkflowOfDelivery = data[i].values[data[i].values.length-1];

          if (lastWorkflowOfDelivery.endTime < now) {
            currentStation = 6; // last station
          };
        }
        data[i].currentStation = currentStation;


      };
      return data;
    }

    function stationCountCalc(data){ // [7, 5, 5, 1, 4, 1, 1, 1] Gets the number of deliveries for every station
      var stationCounts =[0,0,0,0,0,0,0];      //[7, 5, 5, 1, 4, 1, 1, 1]


      for(var i = 0;i<data.length;i++){
        stationCounts[data[i].currentStation]++;
      }
      for (var i = 0; i < stationCounts.length; i++) { //make sure they have at least 1
        stationCounts[i] = stationCounts[i] || 1;
      };

      return stationCounts;
    }

    function stationStackedCountCalc(stationCounts){ //[7, 12, 17, 18, 22, 23, 24, 25]
      var stationStackedCount=[0,0,0,0,0,0,0];

      stationStackedCount[0] = stationCounts[0];
      for (var i = 1; i < stationCounts.length; i++) {
        stationStackedCount[i] = stationStackedCount[i-1]+ stationCounts[i];
      };

      return stationStackedCount;
    }

    function stationStackedCalc(stationCounts,stationStackedCount,stations){//stacks each station with its y0 index and height
      var stationStacked=[];                     //[Object(name:EnRoute, y:7,y0:0),Object...]

      stationStacked[0]={
                          "y0":0,
                          "y":stationCounts[0],
                          "name": stations[0]}

      //this needs to factor in zooming, or add it to zoom section
      for (var i = 1; i < stationStackedCount.length; i++) {
        stationStacked[i] = {
                              "y0":stationStackedCount[i-1],
                              "y":stationCounts[i],
                              "name":stations[i]
                            };
      };
      return stationStacked
    }

    function stackDeliveriesCalc(stationStackedCount,stationData) { //we set the starting yIndex. of each Delivery.  We have to account for stations w/o a delivery

      for (var i = 0; i < stationData.length; i++) {
        for (var j = 0; j < stationData[i].values.length; j++) {
            if(stationData[i].key == 0){
              stationData[i].values[j].yIndex = j;
            }else {
              stationData[i].values[j].yIndex = stationStackedCount[stationData[i].key-1] + j;
            }
        }
      }

      return stationData;
    }

    function compare(a,b) {
      if (a.currentStation < b.currentStation)
        return -1;
      else if (a.currentStation > b.currentStation)
        return 1;
      else
        return 0;
    }

    function isTimeBetweenTime(time, start,end){
      return start <= time && time <= end;
    }

    function generateShapes(){
      d3.xml("img/icn-vehicle-common.svg", "image/svg+xml", function(error, xml) {
        if (error) throw error;
        console.log(xml.documentElement);
        return xml.documentElement;
      });
    }

    function generateWorkflows(startOfDayHour){
      var workflows=[];
      for(var i = 21; i > 0; i--){
        variation =        Math.random() * 1;
        variationMinutes = Math.random() * 60;
  // new Date(now.getTime() + 1*60000);
        workflows.push({  startTime: new Date(new Date(nowYear, nowMonth, nowDay,startOfDayHour+(i*0.2),28).getTime()+(i*6*60000)),
                          endTime:   new Date(new Date(nowYear, nowMonth, nowDay,startOfDayHour+(i*0.2),48).getTime()+(i*6*60000)),
                          delivery: i,
                          station:Math.round(1),
                        });
        workflows.push({  startTime: new Date(new Date(nowYear, nowMonth, nowDay,startOfDayHour+(i*0.2),56).getTime()+(i*6*60000)),
                          endTime:   new Date(new Date(nowYear, nowMonth, nowDay,startOfDayHour+(i*0.2)+1,40).getTime()+(i*6*60000)),
                          delivery: i,
                          station:Math.round(2),
                        });
        workflows.push({  startTime: new Date(new Date(nowYear, nowMonth, nowDay,startOfDayHour+(i*0.2)+1, 44).getTime()+(i*6*60000)),
                          endTime:   new Date(new Date(nowYear, nowMonth, nowDay,startOfDayHour+(i*0.2)+2, 20).getTime()+(i*6*60000)),
                          delivery: i,
                          station:Math.round(3),
                        });
        workflows.push({  startTime: new Date(new Date(nowYear, nowMonth, nowDay,startOfDayHour+(i*0.2)+2,22).getTime()+(i*6*60000)),
                          endTime:   new Date(new Date(nowYear, nowMonth, nowDay,startOfDayHour+(i*0.2)+4,12).getTime()+(i*6*60000)),
                          delivery: i,
                          station:Math.round(4),
                        });
        workflows.push({  startTime: new Date(new Date(nowYear, nowMonth, nowDay,startOfDayHour+(i*0.2)+4,15).getTime()+(i*6*60000)),
                          endTime:   new Date(new Date(nowYear, nowMonth, nowDay,startOfDayHour+(i*0.2)+4,40).getTime()+(i*6*60000)),
                          delivery: i,
                          station:Math.round(5),
                        });
      }
      return workflows;
    }

    
  </script>
</html>

